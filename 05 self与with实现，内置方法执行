#################self 实例化指向###################

# class person:

#     def __init__(self):
#         print(person,id(person))

#     def action(self):
#         # print(person,id(person))
#         # print(self)
#         print('self关键字:',id(self))
#         pass
#     pass
# person().action()
# boy = person()
# boy.action()
# girl = person()
# girl.action()
# print('boy实例化对象:',id(boy))
# print('girl实例化对象:',id(girl))

#################################################################
# When an instance method object is called, the underlying function (__func__) is called, inserting the class instance (__self__) in front of the argument list. For instance, when C is a class which contains a definition for a function f(), and x is an instance of C, calling x.f(1) is equivalent to calling C.f(x, 1).
# When an instance method object is derived from a class method object, the “class instance” stored in __self__ will actually be the class itself, so that calling either x.f(1) or C.f(1) is equivalent to calling f(C,1) where f is the underlying function.

# class MyClass:

#     """A simple example class"""

#     i = 12345

#     def f():
#         return 'hello fffff'
#     def g(self):
#         return 'hello ggggg'

# x = MyClass()
# print(x.f)
# print(x.f())
# print(MyClass.f())
# print(MyClass().f())
# print(x.g)
# print(x.g())
# print(MyClass.g())
# print(MyClass().g())
# print(type(x.f))
# print(type(MyClass.f))
# print(type(MyClass().f))
# print(type(x.g))
# print(type(MyClass.g))
# print(type(MyClass().g))

# print(MyClass().g.__func__)
# print(MyClass().g.__func__.__get__(MyClass))


################## with类 实现方法 ##################################

# class Test(object):

#     def __init__(self,name,flag):
#         self.filename = name
#         self.flag = flag
    
#     def __enter__(self):
#         print ("__enter__:Open %s"%self.filename)
#         self.f = open(self.filename,self.flag)
#         return self.f
        
#     def __exit__(self,Type, value, traceback):

#         print ("__exit__:Close %s"%self.filename)
#         self.f.close()
        
#     def __del__(self):
#         print ("__del__")
        
# if __name__ == "__main__":
#     with Test('test.txt','r+') as ff:
#         content = ff.read()
#         print (content)
#     print ("end")

####################################################

# class person:

#     def __init__(self,name):
#         print('__init__方法执行')
#         self.name = name                  #init不能有返回值
          super(person, self).__init__(*args, **kwargs)
#     def __str__(self):
#         print('__str__方法执行')
#         return ('__str__方法返回')         #打印时执行,不写会打印内存对象,重写后必须有返回值,否则使用print无法打印,TypeError: __str__ returned non-string
#     def __new__(cls,*args):
#         print('__new__方法执行')
#         return ('__new__方法返回')         #类准备将自身实例化时调用，默认是调用该类的直接父类的__new__()方法来构造该类的实例，
#         # return object.__new__(cls)        ##为对象分配空间：super().__new__(cls)， #返回对象的引用
#     def __call__(self):
#         print('__call__方法执行')          #调用一个对象时，实际上调用的是它的 __call__ 方法
#         return ('__call__方法返回')
#     def __del__(self):                    #类包不报错都会执行
#         # input('程序等待中.......请输入： ')
#         print('__del__方法执行')


# xm = person('xiaoming')
# print(xm)
# print(xm())                               #调用一个对象时，实际上调用的是它的 __call__ 方法



###############################################################

class F1(object):
　　#重写__new__方法，返回这个重写的__new__方法
    def __new__(cls, *args, **kwargs):
        return 123

obj=F1() #实例化对象是谁取决于__new__方法,__new__返回什么就是什么
print(obj,type(obj))  #打印结果：123 <class 'int'>


class F2(object):
    pass

class F3(object):
    def __new__(cls, *args, **kwargs):
        return F2()

obj=F3()    #实例化对象是谁取决于__new__方法,__new__返回什么就是什么
print(obj)  #<__main__.F2 object at 0x00000210119BA4A8>

如果要得到当前类的实例，应当在当前类中的 __new__() 方法语句中调用当前类的父类的 __new__() 方法。
例如，如果当前类是直接继承自 object，那当前类的 __new__() 方法返回的对象应该为：
def __new__(cls, *args, **kwargs):
    ...
    return object.__new__(cls)
__new__至少要有一个参数cls，代表要实例化的类，此参数在实例化时由Python解释器自动提供

__new__必须要有返回值，返回实例化出来的实例，这点在自己实现__new__时要特别注意，可以return父类__new__出来的实例，或者直接是object的__new__出来的实例

__init__有一个参数self，就是这个__new__返回的实例，__init__在__new__的基础上可以完成一些其它初始化的动作，__init__不需要返回值


####################################### @classmethod #######################################

# class A(object):
#     bar = 1
#     def func1(self):  
#         print ('foo') 
#     @classmethod
#     def func2(cls):
#         print ('func2')
#         print (cls.bar)
#         cls().func1()   # 调用 foo 方法

# A().func1()             # 需要实例化
# A.func2()               # 不需要实例化
