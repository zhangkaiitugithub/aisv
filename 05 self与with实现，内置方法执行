#################self 实例化指向###################

# class person:

#     def __init__(self):
#         print(person,id(person))

#     def action(self):
#         # print(person,id(person))
#         # print(self)
#         print('self关键字:',id(self))
#         pass
#     pass
# person().action()
# boy = person()
# boy.action()
# girl = person()
# girl.action()
# print('boy实例化对象:',id(boy))
# print('girl实例化对象:',id(girl))

#################################################################
# When an instance method object is called, the underlying function (__func__) is called, inserting the class instance (__self__) in front of the argument list. For instance, when C is a class which contains a definition for a function f(), and x is an instance of C, calling x.f(1) is equivalent to calling C.f(x, 1).
# When an instance method object is derived from a class method object, the “class instance” stored in __self__ will actually be the class itself, so that calling either x.f(1) or C.f(1) is equivalent to calling f(C,1) where f is the underlying function.

# class MyClass:

#     """A simple example class"""

#     i = 12345

#     def f():
#         return 'hello fffff'
#     def g(self):
#         return 'hello ggggg'

# x = MyClass()
# print(x.f)
# print(x.f())
# print(MyClass.f())
# print(MyClass().f())
# print(x.g)
# print(x.g())
# print(MyClass.g())
# print(MyClass().g())
# print(type(x.f))
# print(type(MyClass.f))
# print(type(MyClass().f))
# print(type(x.g))
# print(type(MyClass.g))
# print(type(MyClass().g))

# print(MyClass().g.__func__)
# print(MyClass().g.__func__.__get__(MyClass))


################## with类 实现方法 ##################################

# class Test(object):

#     def __init__(self,name,flag):
#         self.filename = name
#         self.flag = flag
    
#     def __enter__(self):
#         print ("__enter__:Open %s"%self.filename)
#         self.f = open(self.filename,self.flag)
#         return self.f
        
#     def __exit__(self,Type, value, traceback):

#         print ("__exit__:Close %s"%self.filename)
#         self.f.close()
        
#     def __del__(self):
#         print ("__del__")
        
# if __name__ == "__main__":
#     with Test('test.txt','r+') as ff:
#         content = ff.read()
#         print (content)
#     print ("end")

####################################################

# class person:

#     def __init__(self,name):
#         print('__init__方法执行')
#         self.name = name
#     def __str__(self):
#         return ('__str__方法执行')
#     def __new__(cls,*args):
#         print('__new__方法执行')
#         return object.__new__(cls)
#     def __call__(self):
#         print('__call__方法执行')          #调用一个对象时，实际上调用的是它的 __call__ 方法
#     def __del__(self):                    #类包不报错都会执行
#         input('程序等待中.......请输入： ')
#         print('__del__方法执行')


# xm = person('xiaoming')
# print(xm)
# print(xm())                               #调用一个对象时，实际上调用的是它的 __call__ 方法
# input('程序等待中.......请输入： ')


###############################################################

new 先于 init 先于 str 先于 repr 可逐个关闭测试
class A:

    def __repr__(self):
        return "this is repr"
    def __str__(self):
        return "this is str"
    def __init__(self):
        print("this  is init")        
    def __new__(self):
        return "this is new"   

a=A()
print(a)

