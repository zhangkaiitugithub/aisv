#################self 实例化指向###################

# class person:

#     def __init__(self):
#         print(person,id(person))

#     def action(self):
#         # print(person,id(person))
#         # print(self)
#         print('self关键字:',id(self))
#         pass
#     pass
# person().action()
# boy = person()
# boy.action()
# girl = person()
# girl.action()
# print('boy实例化对象:',id(boy))
# print('girl实例化对象:',id(girl))

#################################################################
# When an instance method object is called, the underlying function (__func__) is called, inserting the class instance (__self__) in front of the argument list. For instance, when C is a class which contains a definition for a function f(), and x is an instance of C, calling x.f(1) is equivalent to calling C.f(x, 1).
# When an instance method object is derived from a class method object, the “class instance” stored in __self__ will actually be the class itself, so that calling either x.f(1) or C.f(1) is equivalent to calling f(C,1) where f is the underlying function.

# class MyClass:

#     """A simple example class"""

#     i = 12345

#     def f():
#         return 'hello fffff'
#     def g(self):
#         return 'hello ggggg'

# x = MyClass()
# print(x.f)
# print(x.f())
# print(MyClass.f())
# print(MyClass().f())
# print(x.g)
# print(x.g())
# print(MyClass.g())
# print(MyClass().g())
# print(type(x.f))
# print(type(MyClass.f))
# print(type(MyClass().f))
# print(type(x.g))
# print(type(MyClass.g))
# print(type(MyClass().g))

# print(MyClass().g.__func__)
# print(MyClass().g.__func__.__get__(MyClass))


################## with类 实现方法 ##################################

# class Test(object):

#     def __init__(self,name,flag):
#         self.filename = name
#         self.flag = flag
    
#     def __enter__(self):
#         print ("__enter__:Open %s"%self.filename)
#         self.f = open(self.filename,self.flag)
#         return self.f
        
#     def __exit__(self,Type, value, traceback):

#         print ("__exit__:Close %s"%self.filename)
#         self.f.close()
        
#     def __del__(self):
#         print ("__del__")
        
# if __name__ == "__main__":
#     with Test('test.txt','r+') as ff:
#         content = ff.read()
#         print (content)
#     print ("end")

####################################################

# class person:

#     def __init__(self,name):
#         print('__init__方法执行')
#         self.name = name                  #init不能有返回值
#     def __str__(self):
#         print('__str__方法执行')
#         return ('__str__方法返回')         #打印时执行,不写会打印内存对象,重写后必须有返回值,否则使用print无法打印,TypeError: __str__ returned non-string
#     def __new__(cls,*args):
#         print('__new__方法执行')
#         return ('__new__方法返回')         #new必须有返回值,否则为none.修改new返回值后,后面的内置方法无法执行
#         # return object.__new__(cls)        #返回父级的new方法,可以顺利执行类默认的其他内置方法
#     def __call__(self):
#         print('__call__方法执行')          #调用一个对象时，实际上调用的是它的 __call__ 方法
#         return ('__call__方法返回')
#     def __del__(self):                    #类包不报错都会执行
#         # input('程序等待中.......请输入： ')
#         print('__del__方法执行')


# xm = person('xiaoming')
# print(xm)
# print(xm())                               #调用一个对象时，实际上调用的是它的 __call__ 方法



###############################################################



