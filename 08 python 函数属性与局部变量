def my_func():
    lis = []
    dic = dict()
    res = lis + ['get', 'func', 'vars']
    words = "Life is short, You need Python!"
    print(words)

print(my_func.__code__.co_varnames)

################################################################################

outerVar="this is a global variable"
def test():
    innerVar="this is a local variable"
    print ("local variables:")
    print (locals())
test()
print ("global variables:")
print (globals())

################################################################################

# def fuc1():
#     #通过一个 ".",使用了fuc2的变量
#     print (fuc2.a)

# def fuc2():
#     #这里需要注意的是，在fuc2函数内部使用a，同样要进行域确定，即
#     #fuc2.a，才能访问
#     fuc2.a = 0

# fuc2()          #不先执行fuc2函数，直接外部调用，会显示。。。。没有a属性
# print (fuc2.a)  #访问fuc2的变量
# fuc2.a = 2      #当在外面进行值变化时，fuc2的变量改变了，从而实现了全局变量的效果
# fuc1()          #全局变量的实现，现在输出的结果是 2

# fuc2(),fuc1()   #可以用逗号写入一行一并执行

#################################### 扩展 ######################################

def fa():
	fa.aa ='aa'
	def aaa():
		print('fa.aaa')
	fa.aaa = aaa

print(fa(),fa.aa)
fa(),print(fa.aa)

fa(),fa.aaa()

FFA = fa
FFA(),FFA.aaa()

FFA = fa()
fa.aaa()


##############################################################################################
# def nil(): 
# 	ss='nil' 
# 	print(ss)
# 	def mm(jj):
# 		print(jj)
# 	nil.mm = mm

# nil() 
# nil.ss='kk' 
# nil()               ####这是因为nil.ss没有指向在nil函数定义的varible ss。
# print(nil.ss)       ####nil.ss表示ss现在是nil对象的属性。nil.ss和nil()里面的ss是完全不同的。
# nil() 

# ####第一个ss是函数的内部变量;第二个是函数的一个属性。他们不参考同一个对象。
# ####这里有一个办法做到这一点，虽然：

# nil()
# nil.mm('jjjj')  调用属性条用内部函数


# def nil():
# 	ss='foo'
# 	return ss

# nil.ss='bar'
# foo=nil()
# bar=nil()

# print(nil.ss)
# print(foo)
# print(bar)


# def apple(): 
# 	if not hasattr(apple, 'ss'):      ##This way it'll only be set inside the function once 
#  		apple.ss = 'nil' 
# 	return apple.ss

# print(apple())
# print(apple.ss)
# apple.ss = 'kk'
# print(apple.ss)
# print(apple())

