
#-----------------------------------------------------------------------------------------------------------------------
# 生成器：


# # mylist = [x*x for x in range(3)]
# # print(mylist)
# mygenerator = (x*x for x in range(3))
# # print(mygenerator)
# # print(next(mygenerator))
# aList = [123, 'xyz', 'zara', 'abc', 123]
# # aList.extend(mygenerator) # python 内置函数list,sum等认识迭代器并运行
# aList += mygenerator
# print('新列表: ', aList)


# language_tuple = ('Spanish', 'Portuguese')
# language_set = {'Chinese', 'Japanese'}
# aList.extend(language_tuple)
# aList.extend(language_set)
# print('新列表: ', aList)


# def h():
#     print ('Wen Chuan')
#     m = yield 5  # Drinking!
#     print ('yd: ',m)
#     print ('We are drinking!')
#     d = yield 12
#     print ('yd: ',d)
#     print ('We are together!')
# c = h()                                              # h()被调用后并没有执行，因为它有yield表达式，因此，我们通过next()语句让它执行。next()语句将恢复Generator执行，并直到下一个yield表达式处
# print(c)

# # print(next(c),'\n------------')                      # 相当于c.send(None)
# # print(next(c),'\n------------')
# # print(next(c),'\n------------')

# print(c.send(None),'\n------------')
# print(c.send('Drinking!'),'\n------------')          # (yield 5)表达式被赋予了'Drinking!'
# print(c.send('Fighting!'),'\n------------')          # (yield 12)表达式被赋予了'Fighting!'

# # c.send(None)
# # c.send('Drinking!')                                  # (yield 5)表达式被赋予了'Fighting!'
# # c.send('Fighting!')


# def func():
#     print ('forloop:')
#     for i in range(10):
#         print(f'--------i:   {i}')
#         a = yield i
#         print(f'========{a} {i}')
# f = func()
# print(f) # 此时生成器还没有运行
# print(next(f))
# print(next(f))
# # print(next(f))


# def fib(n):
#     index = 0
#     a = 0
#     b = 1

#     while index < n:
#         yield (f'index : {index}',b)
#         a,b = b, a+b
#         index += 1
#         print (f'--index : {index}')

# fib = fib(4)
# print(fib)
# print(next(fib))
# print(next(fib))
# print(next(fib))
# print(next(fib))
# print(next(fib))


# import sys
# def Fibonacci(n):
#     a, b, counter = 0, 1, 0
#     while True:
#         if(counter > n):
#             return
#         sm = yield counter,a
#         a, b = b, a + b
#         counter += 1
#         print('yienum:',sm)
# f = Fibonacci(15)
# sdnum = -1
# while True:
#     try:
#         # print(sdnum,next(f), end="\n")
#         sendarms = [None,0,1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
#         sdnum += 1 
#         print(sendarms[sdnum],' : ',f.send(sendarms[sdnum]), end="\n")
#     except StopIteration:
#         sys.exit()


# import sys,time
# def fib(n):
#     a,b,index = 0,1,0
#     while index < n:
#         sleep = yield b
#         print('等待%s秒' %sleep)
#         time.sleep(sleep)
#         a,b = b, a+b
#         index += 1

# fib = fib(20)
# print(fib.send(None))   # 效果等同于print(next(fib))
# while True:
#     try:
#         print(fib.send(2), end="\n")
#     except StopIteration:
#         sys.exit()


# def fun_inner():
#     i = 0
#     while True:
#         print('*************')
#         i = yield 'inner: ',i
#         print('-------------')
# def fun_outer():
#     a = 0
#     b = 1
#     print('=============')
#     inner = fun_inner()
#     inner.send(None)
#     print('. . . . . . .')
#     while True:
#         a = inner.send(b)
#         b = yield a

# outer = fun_outer()
# outer.send(None)
# for i in range(5):
#     print(outer.send(i))


# def fun_inner():
#     i = 0
#     while True:
#         i = yield i
# def fun_outer():
#     yield from fun_inner()

# if __name__ == '__main__':
#     outer = fun_outer()
#     outer.send(None)
#     for i in range(5):
#         print(outer.send(i))


def yie():
    for i in range(10):
        yield i
gen01 =yie()

def yif():
    yield from range(10)
gen02 = yif()

while True:
    print('gen01: ' , next(gen01))
    print('gen02: ' , next(gen02))
    print('----------')


# class myiter(object):
#         def __init__(self,count):
#             self.count=count
#         def __iter__(self):
#             return self
#         def __next__(self):
#             if(0>=self.count):
#                 raise StopIteration()
#             else:
#                 self.count -= 1
#                 return self.count
                
# for e in myiter(4):
#     print(e)

## #构建一个myiter(4)对象it
## it = myiter(4)
## #循环调用it的__next__函数
## while 1:
##         e=it.__next__()
##         print(e)


# class fy_generator(object):
#         def __init__(self,count):
#             self.count=count
#         def __iter__(self):
#             return self
#         def __next__(self):
#             c=self.count
#             while c>0:
#                 c=c-1
#                 yield c


# it = fy_generator(4)
# e=it.__next__()
# print(e)



# for i in range(1,10):
#     for j in range(1,i+1):
#         if j<i:
#             print(i,'*',j,'=',i*j,end='  ')
#         else:
#             print(i,'*',j,'=',i*j)


# def chain(*args):
#     for i in args:
#         # for m in i:
#         #     yield m
#         yield from i
# p = list(chain("1234", "AB", [1, 2, 3, 4, 5]))
# print(p)



# ---------------------------------------------------------------------------------------------------------------------------------

# 在使用yield生成器的时候，如果使用for语句去迭代生成器，则不会显式的出发StopIteration异常，而是自动捕获StopIteration异常，所以如果遇到return，只是会终止迭代，而不会触发异常，故而也就没办法获取return的值。如下：

# def my_generator():
#     for i in range(5):
#         if i==2:
#             return '我被迫中断了'
#         else:
#             yield i
 
# def main(generator):
#     try:
#         for i in generator:  #不会显式触发异常，故而无法获取到return的值
#             print(i)
#     except StopIteration as exc:
#         print(exc.value)
 
# g=my_generator()  #调用
# main(g)

# 使用next（g）一次一次迭代，则会显式触发异常，但要获取return的返回值，我需要如下操作：

# def my_generator():
#     for i in range(5):
#         if i==2:
#             return '我被迫中断了'
#         else:
#             yield i
 
# def main(generator):
#     try:
#         print(next(generator))   #每次迭代一个值，则会显式出发StopIteration
#         print(next(generator))
#         print(next(generator))
#         print(next(generator))
#         print(next(generator))
#     except StopIteration as exc:
#         print(exc.value)     #获取返回的值
 
# g=my_generator()
# main(g)

# 使用yield from来完成上面的同样的功能：

def my_generator():
    for i in range(5):
        if i==2:
            return '我被迫中断了'
        else:
            yield i
 
def wrap_my_generator(wtor):  # 定义一个包装“生成器”的生成器，它的本质还是生成器
    result=yield from wtor    # 自动触发StopIteration异常，并且将return的返回值赋值给yield from表达式的结果，即result
    print(result)
 
def main(mwtor):
    for j in mwtor:
        print(j)

mg=my_generator()
wra_my_g=wrap_my_generator(mg)
main(wra_my_g)  #调用


# for i in range(1,10):
#     for j in range(1,i+1):
#         if j<i:
#             print(i,'*',j,'=',i*j,end='  ')
#         else:
#             print(i,'*',j,'=',i*j)


# def chain(*args):
#     for i in args:
#         # for m in i:
#         #     yield m
#         yield from i
# p = list(chain("1234", "AB", [1, 2, 3, 4, 5]))
# print(p)


#利用yield from语句向生成器（协程）传送数据
#传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。
#如果改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，换回生产者继续生产，效率极高：
# import time
# def  consumer_work(len):
#     # 读取send传进的数据，并模拟进行处理数据
#     print("writer:")
#     w=''
#     while True:
#         w = yield w    # w接收send传进的数据,同时也是返回的数据
#         print('[CONSUMER] Consuming %s...>> ', w)
#         w*=len #将返回的数据乘以100
#         time.sleep(1) 
# def consumer(coro):
#     yield from coro#将数据传递到协程(生成器)对象中
  
# def produce(c):
#     c.send(None)# "prime" the coroutine
#     for i in range(5):
#         print('[Produce] Producing %s----', i)
#         w=c.send(i)#发送完成后进入协程中执行
#         print('[Produce] receive %s----', w)
#     c.close()
     
# c1=consumer_work(100)
# produce(consumer(c1))



# ---------------------------------------------------------------------------------------------------------------------------------

from collections.abc import Iterable,Iterator

a = [1,2,3,4]

# print(issubclass(list,Iterable))

# print(isinstance(a, Iterable))
# print(isinstance(a, Iterator))

# print(a.__iter__())

# print(Iterable.__abstractmethods__)


# print(iter(a))
# print(isinstance(iter(a), Iterator))

# b = iter(a)
# print(dir(a))
# print('-'*60)
# print(dir(b))
# print(iter(b) is b)


# class aber():
#     def __iter__():
#         pass
# ab =aber()
# print (isinstance(ab,Iterable))
# print (isinstance(ab,Iterator))
# print('-------------------------------------------------')
# 遍历访问__getitem__方法，迭代访问 __iter__方法

# class aber():
#     def __iter__():
#         pass
#     def __next__():
#         pass
# ab =aber()
# print (isinstance(ab,Iterable))
# print (isinstance(ab,Iterator))
# print('-------------------------------------------------')
# class abor():
#     def __getitem__(self,idx):  # idx默认0到无穷的序号，for_i_in的i的序号 
#         return idx
# cd =abor()
# print (isinstance(cd,Iterable))
# print (isinstance(cd,Iterator))
# for i in cd:
#     print(i)



# print(*map(lambda x, y, z: (x, y, z), range(0, 3), range(3, 6), range(6, 9)))


# print('-------------------------------------------------')

import itertools

# print(*itertools.islice('adfasdfa',1,5,1))
 
# er = itertools.count()
# print(next(er))
# print(next(er))

# iterator = (itertools.count(start = 1, step = 2))                    # 使用时必须格外小心itertools.count(),因为很容易陷入无限循环
# print(*list(next(iterator) for _ in range(5)))

# print(*zip(itertools.count(start = 1,step = 4), ['a','b','c']))


# print(*itertools.product('ABCD', 'xy'))


# print([item for item in itertools.product("abc", repeat=2)])

# print(list(map(pow, range(10), itertools.repeat(2)))) 

# print(list(itertools.chain(['a', 'b', 'c'],{0, 0, 1})))


# print([data for data in list(itertools.combinations([1,3,5,7,9,11,13,15], 3)) if sum(data) == 35])




# print('-------------------------------------------------')

# # 并行迭代
# 情景假设：某个班级的数学成绩，英语成绩，语文成绩分别存在一个列表中，求每个学生的总分
# 对于并行迭代可以使用zip函数
# from random import randint
# chinese = [randint(60, 100) for _ in range(40)]
# math = [randint(60, 100) for _ in range(40)]
# english = [randint(60, 100) for _ in range(40)]
# total = []
# for x, y, z in zip(chinese, math, english):
#     total.append(x + y + z)
# print(total)

# # # 串行迭代:
# # 情景假设：若干个班级的数学成绩存在多个列表中，求分数高于80分的人
# # 对于串行迭代可以使用itertools.chain函数
# from itertools import chain
# class1 = [randint(60, 100) for _ in range(40)]
# class2 = [randint(60, 100) for _ in range(40)]
# class3 = [randint(60, 100) for _ in range(40)]
# num = list(filter(lambda x: x >= 80, chain(class1, class2, class3)))
# print(num)
